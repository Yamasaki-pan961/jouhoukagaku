<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>仮想物理実験室：球体の自由落下運動</title>
  <style>
    /* 外部スタイルシートの読み込み */
    @import "../stylesheet/jquery-ui-1.9.2.custom.css";
    /* jQueryUI用CSS */
    @import "../stylesheet/jquery.jqplot.css";
    /* jqPlot用CSS */
    @import "../stylesheet/laboratory_r2.css";
    /* 仮想物理実験室用 CSS */
  </style>
  <!-- 外部JavaScriptファイルの読み込み -->
  <script src="../javascript/jquery-1.8.3.js"></script> <!-- jQuery用ライブラリ -->
  <script src="../javascript/jquery-ui-1.9.2.custom.js"></script> <!-- jQueryUI用ライブラリ -->
  <script src="../javascript/three_r55.js"></script> <!-- Three.js用ライブラリ -->
  <script src="../javascript/TrackballControls_r55.js"></script> <!-- トラックボールコントロール用ライブラリ -->
  <script src="../javascript/jquery.jqplot_1.0.4.js"></script> <!-- jqPlot用ライブラリ             -->
  <script src="../javascript/plugins/jqplot.canvasTextRenderer.js"></script> <!-- canvasテキスト描画用プラグイン -->
  <script src="../javascript/plugins/jqplot.canvasAxisTickRenderer.js"></script> <!-- canvas目盛描画用プラグイン     -->
  <script src="../javascript/plugins/jqplot.canvasAxisLabelRenderer.js"></script> <!-- canvas軸ラベル描画用プラグイン -->
  <script src="../javascript/plugins/jqplot.logAxisRenderer.js"></script> <!-- 対数グラフ描画用プラグイン     -->
  <script src="../javascript/plugins/jqplot.highlighter.js"></script> <!-- ハイライト表示用プラグイン     -->
  <script src="../javascript/plugins/jqplot.cursor.js"></script> <!-- カーソル描画用プラグイン       -->
  <script src="../javascript/plot2D_r5.js"></script> <!-- ２次元グラフ描画クラス         -->
  <script>
    ////////////////////////////////////////////////////////////////////
    // windowイベントの定義
    ////////////////////////////////////////////////////////////////////
    //HTML文書読み込み完了後に実行するイベントの定義
    //（すべてのHTML文書を読み込んでいなければ参照不能の要素があるため）
    window.addEventListener("load", function () {
      resizeTo(850, 610);
      initEvent();  //イベントの準備
      plotStart();  //jqPlotスタート関数の実行
      threeStart(); //Three.jsのスタート関数の実行
    });

    /////////////////////////////////////////////////////////////////////////
    // 物理系の定義
    ///////////////////////////////////////////////////////////////////////////
    var dt = 0.001;   //1フレームあたりの時間間隔
    var step = 0;    //ステップ数
    var skip = 100;     //計算間引数
    var skip_data = 5;  //プロットデータ間引数
    var g = 9.8;      //重力定数

    //Plot2D用オブジェクト
    let plot2D_position; //位置ベクトル
    let plot2D_velocity; //速度ベクトル
    let plot2D_energy;

    //一時停止フラグ
    var restartFlag = false; //再計算フラグ
    var stopFlag = true;     //一時停止フラグ
    let isControl = true;
    ///////////////////////////////////
    // 球クラスの定義
    ///////////////////////////////////
    var Ball = function (parameter) {
      this.set(parameter);
    };
    Ball.prototype = {
      constructor: Ball, //コンストラクタ

      //ベルレ法アルゴリズムによる時間発展
      timeEvolution: function (dt) {

        //力の取得
        const f = this.calculateForce();

        //加速度ベクトルの更新
        this.ax = f.x / this.mass;
        this.ay = f.y / this.mass;
        this.az = f.z / this.mass;

        //現時刻の位置ベクトルを一時保存
        var x_ = this.x;
        var y_ = this.y;
        var z_ = this.z;

        //次時刻の位置の計算（x_{n+1} = 2x_n - x_{n_1} + a_{n}\Delta t^2 ）
        this.x = 2 * this.x - this.x_1 + this.ax * dt * dt;
        this.y = 2 * this.y - this.y_1 + this.ay * dt * dt;
        this.z = 2 * this.z - this.z_1 + this.az * dt * dt;

        //速度ベクトルの計算（v_）
        this.vx = (this.x - this.x_1) / (2 * dt);
        this.vy = (this.y - this.y_1) / (2 * dt);
        this.vz = (this.z - this.z_1) / (2 * dt);

        //次時刻の計算時に利用する「x_{n_1}」の保存
        this.x_1 = x_;
        this.y_1 = y_;
        this.z_1 = z_;

        //床との衝突
        if (this.z < this.radius) {
          var tmp_z = this.z_1;
          this.z_1 = this.z;
          this.z = tmp_z;
        }
      },
      //力の計算
      calculateForce: function () {
        var fx = 0;
        var fy = 0;
        var fz = -this.mass * g;
        return { x: fx, y: fy, z: fz };
      },
      //ベルレ法による必要な初期値の計算
      calculateInitialCondition: function (dt) {
        //力の取得
        const f = this.calculateForce();
        //加速度ベクトルの取得
        this.ax = f.x / this.mass;
        this.ay = f.y / this.mass;
        this.az = f.z / this.mass;
        //「x_{-1}」の計算
        this.x_1 = this.x - this.vx * dt + 1 / 2 * this.ax * dt * dt;
        this.y_1 = this.y - this.vy * dt + 1 / 2 * this.ay * dt * dt;
        this.z_1 = this.z - this.vz * dt + 1 / 2 * this.az * dt * dt;
      },
      //力学的エネルギーの計算
      calculateEnergy: function () {
        //速度の大きさの２乗の計算
        var v2 = this.vx * this.vx + this.vy * this.vy + this.vz * this.vz;
        //運動エネルギーの計算
        var kinetic = 1 / 2 * this.mass * v2;
        //ポテンシャルエネルギーの計算
        var potential = this.mass * g * this.z_1;
        //力学的エネルギーをオブジェクトで返す
        return { kinetic: kinetic, potential: potential };
      },
      set: function (parameter) {
        //半径
        this.radius = parameter.radius;
        //質量
        this.mass = parameter.mass;

        //位置ベクトル
        this.x = parameter.x;
        this.y = parameter.y;
        this.z = parameter.z;

        //速度ベクトル
        this.vx = parameter.vx;
        this.vy = parameter.vy;
        this.vz = parameter.vz;

        //前時刻の位置ベクトル
        this.x_1;
        this.y_1;
        this.z_1;

        //初期位置の計算
        this.calculateInitialCondition(dt);

        //時系列プロットデータ用配列
        this.data_x = [];  //x座標
        this.data_y = [];  //y座標
        this.data_z = [];  //z座標
        this.data_vx = []; //vx座標
        this.data_vy = []; //vy座標
        this.data_vz = []; //vz座標
        this.data_kinetic = [];   //運動エネルギー
        this.data_potential = []; //ポテンシャルエネルギー
        this.data_energy = [];    //力学的エネルギー

        //プロットデータ配列に初期値を代入
        this.data_x.push([0, this.x]);
        this.data_y.push([0, this.y]);
        this.data_z.push([0, this.z]);
        this.data_vx.push([0, this.vx]);
        this.data_vy.push([0, this.vy]);
        this.data_vz.push([0, this.vz]);

        //初期力学的エネルギーの計算とプロットデータ配列に初期値を代入
        var energy = this.calculateEnergy();
        this.data_kinetic.push([0, energy.kinetic]);
        this.data_potential.push([0, energy.potential]);
        this.data_energy.push([0, energy.kinetic + energy.potential]);

      }
    };

    //球クラスのインスタンスの生成
    var balls = [
      new Ball({
        radius: 5,  //球の半径
        mass: 1,                //質量
        x: 0, y: 10, z: 30,     //位置ベクトル
        vx: 0, vy: 0, vz: 0    //速度ベクトル
      }),
      new Ball({
        radius: 5,  //球の半径
        mass: 1,                //質量
        x: 10, y: 0, z: 20,     //位置ベクトル
        vx: 0, vy: 0, vz: 0    //速度ベクトル
      }),

    ];

    ////////////////////////////////////////////////////////////////////
    //jqPlotスタート関数
    ////////////////////////////////////////////////////////////////////
    function plotStart() {
      //座標グラフ描画
      plot2D_position = new Plot2D("canvas-frame_position");
      //オプションの設定
      plot2D_position.options.axesDefaults.tickOptions.formatString = ''; //目盛フォーマット
      plot2D_position.options.axes.xaxis.label = "time [s]";              //x軸ラベル
      plot2D_position.options.axes.yaxis.label = "position [m]";          //y軸ラベル
      plot2D_position.options.axes.yaxis.labelOptions = { angle: -90 };   //ラベル回転角
      plot2D_position.options.axes.xaxis.min = 0;                         //目盛の最小値
      plot2D_position.options.legend.show = true;                         //凡例の有無
      plot2D_position.options.legend.location = 'ne';                     //凡例の位置 
      var series = []; //データ列オプション用配列

      for (let index in balls) {
        series.push({
          showLine: true,              //線描画の有無
          label: `x座標[${index}]`,              //凡例の設定
          markerOptions: { show: true } //点描画の有無
        });
        series.push({
          showLine: true,              //線描画の有無
          label: `y座標[${index}]`,              //凡例の設定
          markerOptions: { show: true } //点描画の有無
        });
        series.push({
          showLine: true,              //線描画の有無
          label: `z座標[${index}]`,              //凡例の設定
          markerOptions: { show: true } //点描画の有無
        });
      }
      plot2D_position.options.series = series; //データ列オプションの代入

      //速度グラフ描画
      plot2D_velocity = new Plot2D("canvas-frame_velocity");
      //オプションの設定
      plot2D_velocity.options.axesDefaults.tickOptions.formatString = ''; //目盛フォーマット
      plot2D_velocity.options.axes.xaxis.label = "time [s]";              //x軸ラベル
      plot2D_velocity.options.axes.yaxis.label = "velocity [m/s]";         //y軸ラベル
      plot2D_velocity.options.axes.yaxis.labelOptions = { angle: -90 };   //ラベル回転角
      plot2D_velocity.options.axes.xaxis.min = 0;                         //目盛の最小値
      plot2D_velocity.options.legend.show = true;                         //凡例の有無
      plot2D_velocity.options.legend.location = 'ne';                     //凡例の位置 
      series = []; //データ列オプション用配列
      for (let index in balls) {
        series.push({
          showLine: true,           //線描画の有無
          label: `vx[${index}]`,              //凡例の設定
          markerOptions: { show: true } //点描画の有無
        });
        series.push({
          showLine: true,            //線描画の有無
          label: `vy[${index}]`,              //凡例の設定
          markerOptions: { show: true } //点描画の有無
        });
        series.push({
          showLine: true,           //線描画の有無
          label: `vz[${index}]`,              //凡例の設定
          markerOptions: { show: true } //点描画の有無
        });
      }
      plot2D_velocity.options.series = series; //データ列オプションの代入


      //エネルギーグラフ描画
      plot2D_energy = new Plot2D("canvas-frame_energy");
      plot2D_energy.options.axesDefaults.tickOptions.formatString = '';
      plot2D_energy.options.axes.xaxis.label = "time [s]";
      plot2D_energy.options.axes.yaxis.label = "Energy [J]";
      plot2D_energy.options.axes.yaxis.labelOptions = { angle: -90 };
      plot2D_energy.options.axes.xaxis.min = 0;
      plot2D_energy.options.legend.show = true;      //凡例の有無
      plot2D_energy.options.legend.location = 'ne';  //凡例の位置 
      series = []; //データ列オプション用配列
      for (let index in balls) {
        series.push({
          showLine: true,              //線描画の有無
          label: `運動エネルギー[${index}]`,     //凡例の設定
          markerOptions: { show: true } //点描画の有無
        });
        series.push({
          showLine: true,              //線描画の有無
          label: `ポテンシャルエネルギー[${index}]`, //凡例の設定
          markerOptions: { show: true } //点描画の有無
        });
        series.push({
          showLine: true,               //線描画の有無
          label: `力学的エネルギー[${index}]`,    //凡例の設定
          markerOptions: { show: false } //点描画の有無
        });
      }
      plot2D_energy.options.series = series;
    }

    ////////////////////////////////////////////////////////////////////
    // イベント準備関数
    ////////////////////////////////////////////////////////////////////
    function createBallInterface(ball, count) {
      let interface = document.getElementById('ball_interface');
      let table = document.createElement('table');
      table.style = "margin:10px;";
      table.setAttribute('id', `ball_interface_${count}`);
      let caption = document.createElement('caption');
      caption.innerHTML = `Ball[${count}]`;
      table.appendChild(caption);

      var strs = ['x', 'y', 'z', 'vx', 'vy', 'vz'];
      for (var i = 0; i < strs.length; i++) {
        var target = strs[i];
        const setting = {
          min: -100,    //最小値の指定
          max: 100,     //最大値の指定
          step: 1,       //刻み幅の指定
        }
        table.appendChild(
          createTableRow(target, ball, count, setting));
      }
      table.appendChild(
        createTableRow(`radius`, ball, count, { min: 0.1, max: 30, step: 0.1 }));
      table.appendChild(
        createTableRow(`mass`, ball, count, { min: 1, max: 100, step: 1 },));

      interface.appendChild(table);
    }

    function createTableRow(target, ball, count, setting) {
      const value = ball[target];
      let text = document.createElement("p");
      text.innerText = target;
      let elements = [text];
      const id = `${target}_${count}`;
      let slider = document.createElement('div');
      slider.setAttribute('id', `slider_${id}`);

      setting.value = value;
      setting.slide = function (event, ui) {
        var value = ui.value;
        var id = this.id.replace("slider_", "input_");
        document.getElementById(id).value = value;
      }
      slider.style = "width: 120px;";
      elements.push(slider);

      let input = document.createElement('input');
      input.setAttribute('id', `input_${id}`);
      input.setAttribute('class', `number`);
      input.setAttribute('type', `text`);
      input.value = value;
      input.style = "width:20px";

      $(slider).slider(setting);
      input.addEventListener("change", function () {
        //input要素に入力された値を取得する
        var value = parseFloat(this.value) || 0;

        //スライダー位置をinput要素に入力した値にする
        var id = this.id.replace("input_", "slider_"); //id名の書き換え（「input_○」→「slider_○」）
        $('#' + id).slider({ value: value });          //スライダー位置を指定

      });
      elements.push(input);

      let tr = document.createElement("tr");
      for (let index in elements) {
        let td = document.createElement("td");
        td.appendChild(elements[index]);
        tr.appendChild(td);
      }
      return tr;
    }

    function initEvent() {
      //タブ切り替えインターフェースの実装
      $('#tabs').tabs({ selected: 0 /*, fx: { opacity: 'toggle', duration: 100} */ });
      for (let index in balls) {
        createBallInterface(balls[index], index);
      }


      //描画間引数「skip」の指定
      document.getElementById("input_skip").value = skip;
      $('#slider_skip').slider({
        min: 1,      //最小値の指定
        max: 1000,   //最大値の指定
        step: 1,     //刻み幅の指定
        value: skip, //現在の値を指定
        slide: function (event, ui) {  //スライドした時のイベントを登録
          //スライダーの指定した値を取得する
          var value = ui.value;

          //スライダーで指定した値を座標表示用input要素に表示する
          document.getElementById("input_skip").value = value;
        }
      });
      //重力定数「g」の指定
      document.getElementById("input_g").value = g;
      $('#slider_g').slider({
        min: -100,    //最小値の指定
        max: 100,     //最大値の指定
        step: 0.1,    //刻み幅の指定
        value: g,     //現在の値を指定
        slide: function (event, ui) { //スライドした時のイベントを登録
          //スライダーの指定した値を取得する
          var value = ui.value;

          //スライダーで指定した値を座標表示用input要素に表示する
          document.getElementById("input_g").value = value;
        }
      });

      //座標表示用input要素に値を代入
      document.getElementById("input_dt").value = dt; //id名「input_○」の要素の「value」属性に値を代入

      ////ボタンクリックとタブ切り替え時のイベントの設定////////////////////////////////
      //計算開始ボタン
      document.getElementById("startButton").addEventListener("click", function () {
        //再計算用フラグを設定
        restartFlag = true;
        isControl = false;
      });
      //一時停止ボタン
      document.getElementById("stopButton").addEventListener("click", function () {
        //一時停止ボタンの状態により動作を指定
        if (stopFlag) {
          //一時停止フラグを解除
          stopFlag = false;
        } else {
          //一時停止フラグを設定
          stopFlag = true;
          isControl = false;
        }
      });

      document.getElementById("resetButton").addEventListener("click", function () {
        isControl = true;
        for (let index in balls) {
          const strs = ['x', 'y', 'z', 'vx', 'vy', 'vz', 'radius', 'mass'];
          var parameter = {};
          for (let s in strs) {
            const id = `input_${strs[s]}_${index}`
            parameter[strs[s]] = parseFloat(document.getElementById(id).value);
          }
          //球クラスのインスタンスの再生成
          balls[index].set(parameter);
        }

      });
      document.getElementById("incrementButton").addEventListener("click", function () {
        const ball = new Ball({
          radius: 5,  //球の半径
          mass: 1,                //質量
          x: balls.length * 10, y: 10, z: 30,     //位置ベクトル
          vx: 0, vy: 0, vz: 0    //速度ベクトル
        })
        balls.push(ball);
        createBallInterface(ball, balls.length-1);
      });

      document.getElementById("decrementButton").addEventListener("click", function () {
        document.getElementById(`ball_interface_${balls.length-1}`).remove();
        scene.remove(spheres[balls.length-1]);
        balls.pop();
      });

      //1つ目のタブに切り替え時
      document.getElementById("tabList").getElementsByTagName("a").item(0).addEventListener("click", function () {
        //一時停止フラグを設定
        //stopFlag = false;
      });
      //2つ目のタブに切り替え時
      document.getElementById("tabList").getElementsByTagName("a").item(1).addEventListener("click", function () {
        //「pushData」メソッドによるデータ列の初期化
        plot2D_position.clearData();
        plotStart();
        //「pushData」メソッドによるデータの追加
        for (let index in balls) {
          const ball = balls[index];
          plot2D_position.pushData(ball.data_x); //x座標
          plot2D_position.pushData(ball.data_y); //y座標
          plot2D_position.pushData(ball.data_z); //z座標
        }
        plot2D_position.linerPlot();   //メソッドによる再描画

        //一時停止フラグを設定
        stopFlag = true;
      });
      //3つ目のタブに切り替え時
      document.getElementById("tabList").getElementsByTagName("a").item(2).addEventListener("click", function () {
        //「pushData」メソッドによるデータ列の初期化
        plot2D_velocity.clearData();

        //「pushData」メソッドによるデータの追加
        for (let index in balls) {
          const ball = balls[index];
          plot2D_velocity.pushData(ball.data_vx); //vx
          plot2D_velocity.pushData(ball.data_vy); //vy
          plot2D_velocity.pushData(ball.data_vz); //vz
        }
        plot2D_velocity.linerPlot();   //メソッドによる再描画

        //一時停止フラグを設定
        stopFlag = true;
      });
      //4つ目のタブに切り替え時
      document.getElementById("tabList").getElementsByTagName("a").item(3).addEventListener("click", function () {
        plot2D_energy.clearData();

        //「pushData」メソッドによるデータの追加
        for (let index in balls) {
          const ball = balls[index];
          plot2D_energy.pushData(ball.data_kinetic);   //運動エネルギー
          plot2D_energy.pushData(ball.data_potential); //ポテンシャルエネルギー
          plot2D_energy.pushData(ball.data_energy);    //力学的エネルギー
        }
        plot2D_energy.linerPlot();              //メソッドによる再描画

        //ボタンの表示文字列の変更
        document.getElementById("stopButton").value = "停止解除";
        //一時停止フラグを設定
        stopFlag = true;
      });
    }
    ////////////////////////////////////////////////////////////////////
    // Three.jsスタート関数の定義
    ////////////////////////////////////////////////////////////////////
    function threeStart() {
      initThree();  //Three.js初期化関数の実行
      initCamera(); //カメラ初期化関数の実行
      initLight();  //光源初期化関数の実行
      initObject(); //オブジェクト初期化関数の実行
      loop();       //無限ループ関数の実行
    }

    ////////////////////////////////////////////////////////////////////
    // Three.js初期化関数の定義
    ////////////////////////////////////////////////////////////////////

    //グローバル変数の宣言
    var renderer,    //レンダラーオブジェクト
      scene,       //シーンオブジェクト
      canvasFrame; //キャンバスフレームのDOM要素
    function initThree() {
      //キャンバスフレームDOM要素の取得
      canvasFrame = document.getElementById('canvas-frame');

      //レンダラーオブジェクトの生成
      renderer = new THREE.WebGLRenderer({ antialias: true });
      if (!renderer) alert('Three.js の初期化に失敗しました');
      //レンダラーのサイズの設定
      renderer.setSize(canvasFrame.clientWidth, canvasFrame.clientHeight);
      //キャンバスフレームDOM要素にcanvas要素を追加
      canvasFrame.appendChild(renderer.domElement);

      //レンダラークリアーカラーの設定
      renderer.setClearColorHex(0xE1FCFF, 1.0);
      //シャドーマップの利用
      renderer.shadowMapEnabled = true;

      //シーンオブジェクトの生成
      scene = new THREE.Scene();
    }

    ////////////////////////////////////////////////////////////////////
    // カメラ初期化関数の定義
    ////////////////////////////////////////////////////////////////////

    //グローバル変数の宣言
    var camera,    //カメラオブジェクト
      trackball; //トラックボールオブジェクト
    function initCamera() {
      //カメラオブジェクトの生成
      camera = new THREE.PerspectiveCamera(45, canvasFrame.clientWidth / canvasFrame.clientHeight, 1, 10000);
      //カメラの位置の設定
      camera.position.set(100, 0, 30);
      //カメラの上ベクトルの設定
      camera.up.set(0, 0, 1);
      //カメラの中心位置ベクトルの設定
      camera.lookAt({ x: 0, y: 0, z: 100 }); //トラックボール利用時は自動的に無効

      //トラックボールオブジェクトの宣言
      trackball = new THREE.TrackballControls(camera, canvasFrame);

      //トラックボール動作範囲のサイズとオフセットの設定
      trackball.screen.width = canvasFrame.clientWidth;                        //横幅
      trackball.screen.height = canvasFrame.clientHeight;                      //縦幅
      trackball.screen.offsetLeft = canvasFrame.getBoundingClientRect().left;  //左オフセット
      trackball.screen.offsetTop = canvasFrame.getBoundingClientRect().top;    //右オフセット

      //トラックボールの回転無効化と回転速度の設定
      trackball.noRotate = false;
      trackball.rotateSpeed = 2.0;

      //トラックボールの拡大無効化と拡大速度の設定
      trackball.noZoom = false;
      trackball.zoomSpeed = 1.0;

      //トラックボールのカメラ中心移動の無効化と中心速度の設定
      trackball.noPan = false;
      trackball.panSpeed = 1.0;
      trackball.target = new THREE.Vector3(0, 0, 10);

      //トラックボールのスタティックムーブの有効化
      trackball.staticMoving = true;
      //トラックボールのダイナミックムーブ時の減衰定数
      trackball.dynamicDampingFactor = 0.3;
    }

    ////////////////////////////////////////////////////////////////////
    // 光源初期化関数の定義
    ////////////////////////////////////////////////////////////////////

    //グローバル変数の宣言
    var directionalLight,  //平行光源オブジェクト
      ambientLight;      //環境光オブジェクト
    function initLight() {
      //平行光源オブジェクトの生成
      directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0, 0);
      //平行光源オブジェクトの位置の設定
      directionalLight.position.set(200, 200, 500);
      //平行光源オブジェクトの影の生成元
      directionalLight.castShadow = true;
      //平行光源オブジェクトのシーンへの追加
      scene.add(directionalLight);

      //平行光源オブジェクトのシャドウマップのサイズ
      directionalLight.shadowMapWidth = 2048;
      directionalLight.shadowMapHeight = 2048;

      //環境光オブジェクトの生成
      ambientLight = new THREE.AmbientLight(0x777777);
      //環境光オブジェクトのシーンへの追加
      scene.add(ambientLight);
    }

    ////////////////////////////////////////////////////////////////////
    // オブジェクト初期化関数の定義
    ////////////////////////////////////////////////////////////////////

    //グローバル変数の宣言
    var spheres = []; //球オブジェクト
    function initObject() {
      //材質オブジェクトの宣言と生成
      var material = new THREE.MeshLambertMaterial({ color: 0xFF0000, ambient: 0x880000 });

      for (let index in balls) {
        //形状オブジェクトの宣言と生成
        //球オブジェクトの生成
        var geometry = new THREE.SphereGeometry(balls[index].radius, 20, 20);
        spheres.push(new THREE.Mesh(geometry, material));
        //球オブジェクトのシーンへの追加
        scene.add(spheres[index]);
        //球オブジェクトの影の生成元
        spheres[index].castShadow = true;
      }

      //床の描画
      var yuka_n = 20,  //床一辺あたりのタイルの個数
        yuka_w = 10; //タイルの一辺の長さ
      for (var i = -yuka_n / 2; i <= yuka_n / 2; i++) {
        for (var j = -yuka_n / 2; j <= yuka_n / 2; j++) {
          //位置ベクトル
          var x = j * yuka_w;
          var y = i * yuka_w;
          //一辺の長さ「yuka_w」の正方形の形状オブジェクトの宣言と生成
          geometry = new THREE.PlaneGeometry(yuka_w, yuka_w);
          //材質オブジェクトの宣言
          //市松模様とするための材質オブジェクトを生成
          if (Math.abs(i + j) % 2 == 0) {
            material = new THREE.MeshLambertMaterial({ color: 0x999999, ambient: 0x050505 });
          } else {
            material = new THREE.MeshLambertMaterial({ color: 0x4d4d4d, ambient: 0x050505 });
          }
          //平面オブジェクトの宣言と生成
          var plane = new THREE.Mesh(geometry, material);
          //平面オブジェクトの位置の設定
          plane.position.set(x, y, 0);
          //平面オブジェクトに影を描画
          plane.receiveShadow = true;
          //平面オブジェクトのシーンへの追加
          scene.add(plane);
        }
      }
    }

    ////////////////////////////////////////////////////////////////////
    // 無限ループ関数の定義
    ////////////////////////////////////////////////////////////////////
    function loop() {
      //トラックボールによるカメラオブジェクトのプロパティの更新
      trackball.update();

      if (isControl) {
        for (let index in balls) {
          const strs = ['x', 'y', 'z', 'vx', 'vy', 'vz', 'radius', 'mass'];
          var parameter = {};
          for (let s in strs) {
            const id = `input_${strs[s]}_${index}`
            parameter[strs[s]] = parseFloat(document.getElementById(id).value);
          }
          //球クラスのインスタンスの再生成
          balls[index].set(parameter);
        }

      }
      //時刻の取得
      var time = step * dt;
      if (stopFlag == false) {
        for (var k = 0; k < skip; k++) {
          step++;
          time = step * dt;
          for (let index in balls) {
            let ball = balls[index];
            //球体の時間発展
            ball.timeEvolution(dt);

            if (step % (skip * skip_data) == 0) {
              //プロットデータ配列にデータを追加
              ball.data_x.push([time, ball.x]); //x座標
              ball.data_y.push([time, ball.y]); //y座標
              ball.data_z.push([time, ball.z]); //z座標
              ball.data_vx.push([time, ball.vx]); //vx
              ball.data_vy.push([time, ball.vy]); //vy
              ball.data_vz.push([time, ball.vz]); //vz
              var energy = ball.calculateEnergy();
              ball.data_kinetic.push([time, energy.kinetic]);
              ball.data_potential.push([time, energy.potential]);
              ball.data_energy.push([time, energy.kinetic + energy.potential]);
            }
            balls[index] = ball;
          }
        }
      }
      //時刻の取得と出力
      document.getElementById("time").innerHTML = time.toFixed(2);

      var material = new THREE.MeshLambertMaterial({ color: 0xFF0000, ambient: 0x880000 });

      //球オブジェクトの位置ベクトルを設定
      for (let index in balls) {
        const ball = balls[index];
        scene.remove(spheres[index]);
        var geometry = new THREE.SphereGeometry(balls[index].radius, 20, 20);
        spheres[index] = new THREE.Mesh(geometry, material);
        scene.add(spheres[index]);
        spheres[index].position.set(ball.x, ball.y, ball.z);
      }

      //再スタートフラグのチェック
      if (restartFlag == true) {
        //各種計算パラメータの初期化
        step = 0;
        skip = parseInt(document.getElementById("input_skip").value);
        dt = parseFloat(document.getElementById("input_dt").value);
        g = parseFloat(document.getElementById("input_g").value);

        //球クラスのパラメータの初期化
        for (let index in balls) {
          const strs = ['x', 'y', 'z', 'vx', 'vy', 'vz', 'radius', 'mass'];
          parameter = {};
          for (let s in strs) {
            const id = `input_${strs[s]}_${index}`
            parameter[strs[s]] = parseFloat(document.getElementById(id).value);
          }
          //球クラスのインスタンスの再生成
          balls[index].set(parameter);
        }

        //再計算フラグと一時停止フラグの解除
        restartFlag = false;
        stopFlag = false;
        //ボタン表示文字列の変更
        document.getElementById("startButton").value = "再計算スタート";
      }
      //ボタンの表示文字列の変更
      if (stopFlag) {
        document.getElementById("resetButton").style = 'visibility:visible;';
        document.getElementById("stopButton").style = 'visibility:hidden;';
      } else {
        document.getElementById("resetButton").style = 'visibility:hidden;';
        document.getElementById("stopButton").style = 'visibility:visible;';
      }

      //クリアーカラーで初期化
      renderer.clear();
      //レンダリング
      renderer.render(scene, camera);

      //「loop()」関数の呼び出し
      requestAnimationFrame(loop);
    }
  </script>
</head>

<body>
  <!-- タブ切り替えインターフェース領域 -->
  <div id="tabs">

    <!-- タブメニューリスト領域 -->
    <ul id="tabList">
      <li><a href="#tab1">仮想３次元空間</a></li>
      <li><a href="#tab2">時系列プロット(位置ベクトル)</a></li>
      <li><a href="#tab3">時系列プロット(速度ベクトル)</a></li>
      <li><a href="#tab4">時系列プロット(力学的エネルギー)</a></li>
    </ul>

    <!-- タブコンテンツ領域 -->
    <div id="tab1" class="inner">
      <!-- キャンバスフレーム領域-->
      <div id="canvas-frame"></div>

      <!-- コントローラー領域 -->
      <div id="controller">

        <h2>計算パラメータ</h2>
        <table>
          <tr>
            <td>時刻</td>
            <!-- 現在のtime座標 -->
            <td colspan="2"><span id="time">0</span></td>
          </tr>
          <tr>
            <!-- dt -->
            <td>Δt</td>
            <!-- 現在のdt座標 -->
            <td colspan="2"><input type="text" value="" id="input_dt" class="number" style="width:180px"></td>
          </tr>
          <tr>
            <!-- mass -->
            <td>質量</td>
            <!-- mを指定するスライダー -->
            <td>
              <div id="slider_mass" class="slider" style="width:120px"></div>
            </td>
            <!-- 現在のmass -->
            <td><input type="text" value="" id="input_mass" class="number"></td>
          </tr>
          <tr>
            <!-- g -->
            <td>重力定数</td>
            <!-- gを指定するスライダー -->
            <td>
              <div id="slider_g" class="slider" style="width:120px"></div>
            </td>
            <!-- 現在のg -->
            <td><input type="text" value="" id="input_g" class="number"></td>
          </tr>
          <tr>
            <!-- skip -->
            <td>描画間引</td>
            <!-- skipを指定するスライダー -->
            <td>
              <div id="slider_skip" class="slider" style="width:120px"></div>
            </td>
            <!-- 現在のskip座標 -->
            <td><input type="text" value="" id="input_skip" class="number"></td>
          </tr>
        </table>
        <!-- ボタン -->
        <div id="buttonFrame">
          <input type="button" value="計算開始" id="startButton" />
          <input type="button" value="一時停止" id="stopButton" />
          <input type="button" value="リセット" id="resetButton" />
          <input type="button" value="ボール +1" id="incrementButton" style="display: block;"/>
          <input type="button" value="ボール -1" id="decrementButton" style="display: block;"/>

        </div>
      </div>
    </div>

    <!-- タブコンテンツ領域 -->
    <div id="tab2" class="inner">
      <!-- キャンバスフレーム領域-->
      <div id="canvas-frame_position" class="plotFrame"></div>
    </div>
    <!-- タブコンテンツ領域 -->
    <div id="tab3" class="inner">
      <!-- キャンバスフレーム領域-->
      <div id="canvas-frame_velocity" class="plotFrame"></div>
    </div>
    <!-- タブコンテンツ領域 -->
    <div id="tab4" class="inner">
      <!-- キャンバスフレーム領域-->
      <div id="canvas-frame_energy" class="plotFrame"></div>
    </div>
  </div>
  <div id="ball_interface" style="display: flex; justify-content: center;"></div>
</body>

</html>