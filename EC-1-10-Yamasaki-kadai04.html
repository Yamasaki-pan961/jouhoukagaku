<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>仮想物理実験室：球体の自由落下運動</title>
  <style>
    /* 外部スタイルシートの読み込み */
    @import "../stylesheet/jquery-ui-1.9.2.custom.css";
    /* jQueryUI用CSS */
    @import "../stylesheet/jquery.jqplot.css";
    /* jqPlot用CSS */
    @import "../stylesheet/laboratory_r2.css";
    /* 仮想物理実験室用 CSS */
  </style>
  <!-- 外部JavaScriptファイルの読み込み -->
  <script src="../javascript/jquery-1.8.3.js"></script> <!-- jQuery用ライブラリ -->
  <script src="../javascript/jquery-ui-1.9.2.custom.js"></script> <!-- jQueryUI用ライブラリ -->
  <script src="../javascript/three_r55.js"></script> <!-- Three.js用ライブラリ -->
  <script src="../javascript/TrackballControls_r55.js"></script> <!-- トラックボールコントロール用ライブラリ -->
  <script src="../javascript/jquery.jqplot_1.0.4.js"></script> <!-- jqPlot用ライブラリ             -->
  <script src="../javascript/plugins/jqplot.canvasTextRenderer.js"></script> <!-- canvasテキスト描画用プラグイン -->
  <script src="../javascript/plugins/jqplot.canvasAxisTickRenderer.js"></script> <!-- canvas目盛描画用プラグイン     -->
  <script src="../javascript/plugins/jqplot.canvasAxisLabelRenderer.js"></script> <!-- canvas軸ラベル描画用プラグイン -->
  <script src="../javascript/plugins/jqplot.logAxisRenderer.js"></script> <!-- 対数グラフ描画用プラグイン     -->
  <script src="../javascript/plugins/jqplot.highlighter.js"></script> <!-- ハイライト表示用プラグイン     -->
  <script src="../javascript/plugins/jqplot.cursor.js"></script> <!-- カーソル描画用プラグイン       -->
  <script src="../javascript/plot2D_r5.js"></script> <!-- ２次元グラフ描画クラス         -->
  <script>
    ////////////////////////////////////////////////////////////////////
    // windowイベントの定義
    ////////////////////////////////////////////////////////////////////
    //HTML文書読み込み完了後に実行するイベントの定義
    //（すべてのHTML文書を読み込んでいなければ参照不能の要素があるため）
    window.addEventListener("load", function () {
      resizeTo(850, 610);
      initEvent();  //イベントの準備
      threeStart(); //Three.jsのスタート関数の実行
    });

    /////////////////////////////////////////////////////////////////////////
    // 物理系の定義
    ///////////////////////////////////////////////////////////////////////////
    var dt = 0.001;   //1フレームあたりの時間間隔
    var skip = 100;     //計算間引数
    let step = 0;
    var g = 9.8;      //重力定数

    let sideWallWidth = 40;
    let frontWallRange = 60;
    let racketDepth = 5;
    let racketX = - frontWallRange + 20;
    let roofHeight = 40;

    let input_key_buffer = new Array();
    let move = 1;

    let score = 0;

    //一時停止フラグ
    var stopFlag = true;
    let restartFlag = false;
    let gameOverFlag = false;

    //軌跡配列の初期化
    var trajectory = [];

    let Racket = function (parameter) {
      this.x = racketX;
      this.y = parameter.y;
      this.z = parameter.z;
      this.width = parameter.width;
      this.height = parameter.height;
      this.depth = racketDepth;
      this.getL = function () {
        return this.y - this.width / 2;
      }
      this.getR = function () {
        return this.y + this.width / 2;
      }
      this.getT = function () {
        return this.z + this.height / 2;
      }
      this.getB = function () {
        return this.z - this.height / 2;
      }
    }

    const initParam = {
      y: 0,
      z: 20,
      width: 10,
      height: 10,
    };
    let racket = new Racket(initParam);

    ///////////////////////////////////
    // 球クラスの定義
    ///////////////////////////////////
    var Ball = function (parameter) {
      //半径
      this.radius = parameter.radius;
      //質量
      this.mass = parameter.mass;

      //位置ベクトル
      this.x = parameter.x;
      this.y = parameter.y;
      this.z = parameter.z;

      //速度ベクトル
      this.vx = parameter.vx;
      this.vy = parameter.vy;
      this.vz = parameter.vz;

      //前時刻の位置ベクトル
      this.x_1;
      this.y_1;
      this.z_1;

      this.wallBounded = false;

      //初期位置の計算
      this.calculateInitialCondition(dt);

    };
    Ball.prototype = {
      constructor: Ball, //コンストラクタ

      //ベルレ法アルゴリズムによる時間発展
      timeEvolution: function (dt) {

        //力の取得
        const f = this.calculateForce();

        //加速度ベクトルの更新
        this.ax = f.x / this.mass;
        this.ay = f.y / this.mass;
        this.az = f.z / this.mass;

        //現時刻の位置ベクトルを一時保存
        var x_ = this.x;
        var y_ = this.y;
        var z_ = this.z;

        //次時刻の位置の計算（x_{n+1} = 2x_n - x_{n_1} + a_{n}\Delta t^2 ）
        this.x = 2 * this.x - this.x_1 + this.ax * dt * dt;
        this.y = 2 * this.y - this.y_1 + this.ay * dt * dt;
        this.z = 2 * this.z - this.z_1 + this.az * dt * dt;

        //速度ベクトルの計算（v_）
        this.vx = (this.x - this.x_1) / (2 * dt);
        this.vy = (this.y - this.y_1) / (2 * dt);
        this.vz = (this.z - this.z_1) / (2 * dt);

        //次時刻の計算時に利用する「x_{n_1}」の保存
        this.x_1 = x_;
        this.y_1 = y_;
        this.z_1 = z_;

      },
      //力の計算
      calculateForce: function () {
        var fx = 0;
        var fy = 0;
        var fz = -this.mass * g;
        if (this.x > this.radius + frontWallRange) {
          this.ballBounded = true;
          let next_vx = -this.vx;
          fx += (next_vx - this.vx) * this.mass / dt
        }
        if (Math.abs(this.y) > this.radius + sideWallWidth) {
          let next_vy = -this.vy;
          fy += (next_vy - this.vy) * this.mass / dt
        }
        if (this.z <= this.radius) {
          let next_vz = -this.vz;
          fz += (next_vz - this.vz) * this.mass / dt
        }
        if (this.x - this.radius < racket.x + racket.depth / 2 && this.x - this.radius > racket.x - racket.depth / 2 && racket.getL() < this.y && racket.getR() > this.y && racket.getB() < this.z && racket.getT() > this.z) {
          if (this.ballBounded) {
            score++;
            let next_vx = -this.vx;
            let next_vy = this.vy + 20 * (Math.random() - 0.5);
            let next_vz = this.vz + 20 * (Math.random() - 0.3);
            fx += (next_vx - this.vx) * this.mass / dt
            fy += (next_vy - this.vy) * this.mass / dt
            fz += (next_vz - this.vz) * this.mass / dt
            this.ballBounded = false;
          }
        }

        if (-this.x > this.radius + frontWallRange) {
          stopFlag = true;
          gameOverFlag = true;
        }

        return { x: fx, y: fy, z: fz };
      },
      //ベルレ法による必要な初期値の計算
      calculateInitialCondition: function (dt) {
        //力の取得
        const f = this.calculateForce();
        //加速度ベクトルの取得
        this.ax = f.x / this.mass;
        this.ay = f.y / this.mass;
        this.az = f.z / this.mass;
        //「x_{-1}」の計算
        this.x_1 = this.x - this.vx * dt + 1 / 2 * this.ax * dt * dt;
        this.y_1 = this.y - this.vy * dt + 1 / 2 * this.ay * dt * dt;
        this.z_1 = this.z - this.vz * dt + 1 / 2 * this.az * dt * dt;
      },
      //力学的エネルギーの計算
      calculateEnergy: function () {
        //速度の大きさの２乗の計算
        var v2 = this.vx * this.vx + this.vy * this.vy + this.vz * this.vz;
        //運動エネルギーの計算
        var kinetic = 1 / 2 * this.mass * v2;
        //ポテンシャルエネルギーの計算
        var potential = this.mass * g * this.z_1;
        //力学的エネルギーをオブジェクトで返す
        return { kinetic: kinetic, potential: potential };
      }
    };


    const initBallParam = {
      radius: 2,  //球の半径
      mass: 1,                //質量
      x: 0, y: 0, z: 20,     //位置ベクトル
      vx: 20, vy: 0, vz: 0    //速度ベクトル
    };

    //球クラスのインスタンスの生成
    var ball = new Ball(initBallParam);

    ////////////////////////////////////////////////////////////////////
    //jqPlotスタート関数
    ////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////
    // イベント準備関数
    ////////////////////////////////////////////////////////////////////
    function initEvent() {
      //タブ切り替えインターフェースの実装
      $('#tabs').tabs({ selected: 0 /*, fx: { opacity: 'toggle', duration: 100} */ });

      document.getElementById('startButton').addEventListener("click", function () {
        if (!gameOverFlag) {
          if (stopFlag) {
            score = 0;
            stopFlag = false;
            document.getElementById('startButton').value = 'リセット'
          } else {
            stopFlag = true;
            restartFlag = true;
            document.getElementById('startButton').value = 'スタート'
          }
        } else {
          stopFlag = true;
          restartFlag = true;
          gameOverFlag = false;
          document.getElementById('startButton').value = 'スタート'
        }
      })
      document.onkeydown = function (e) {
        input_key_buffer[e.keyCode] = true;
      };

      document.onkeyup = function (e) {
        input_key_buffer[e.keyCode] = false;
      };
    }
    ////////////////////////////////////////////////////////////////////
    // Three.jsスタート関数の定義
    ////////////////////////////////////////////////////////////////////
    function threeStart() {
      initThree();  //Three.js初期化関数の実行
      initCamera(); //カメラ初期化関数の実行
      initLight();  //光源初期化関数の実行
      initObject(); //オブジェクト初期化関数の実行
      loop();       //無限ループ関数の実行
    }

    ////////////////////////////////////////////////////////////////////
    // Three.js初期化関数の定義
    ////////////////////////////////////////////////////////////////////

    //グローバル変数の宣言
    var renderer,    //レンダラーオブジェクト
      scene,       //シーンオブジェクト
      canvasFrame; //キャンバスフレームのDOM要素
    function initThree() {
      //キャンバスフレームDOM要素の取得
      canvasFrame = document.getElementById('canvas-frame');

      //レンダラーオブジェクトの生成
      renderer = new THREE.WebGLRenderer({ antialias: true });
      if (!renderer) alert('Three.js の初期化に失敗しました');
      //レンダラーのサイズの設定
      renderer.setSize(canvasFrame.clientWidth, canvasFrame.clientHeight);
      //キャンバスフレームDOM要素にcanvas要素を追加
      canvasFrame.appendChild(renderer.domElement);

      //レンダラークリアーカラーの設定
      renderer.setClearColorHex(0xE1FCFF, 1.0);
      //シャドーマップの利用
      renderer.shadowMapEnabled = true;

      //シーンオブジェクトの生成
      scene = new THREE.Scene();
    }

    ////////////////////////////////////////////////////////////////////
    // カメラ初期化関数の定義
    ////////////////////////////////////////////////////////////////////

    //グローバル変数の宣言
    var camera,    //カメラオブジェクト
      trackball; //トラックボールオブジェクト
    function initCamera() {
      //カメラオブジェクトの生成
      camera = new THREE.PerspectiveCamera(45, canvasFrame.clientWidth / canvasFrame.clientHeight, 1, 10000);
      //カメラの位置の設定
      camera.position.set(100, 0, 30);
      //カメラの上ベクトルの設定
      camera.up.set(0, 0, 1);
      //カメラの中心位置ベクトルの設定
      camera.lookAt({ x: 0, y: 0, z: 100 }); //トラックボール利用時は自動的に無効

      //トラックボールオブジェクトの宣言
      trackball = new THREE.TrackballControls(camera, canvasFrame);

      //トラックボール動作範囲のサイズとオフセットの設定
      trackball.screen.width = canvasFrame.clientWidth;                        //横幅
      trackball.screen.height = canvasFrame.clientHeight;                      //縦幅
      trackball.screen.offsetLeft = canvasFrame.getBoundingClientRect().left;  //左オフセット
      trackball.screen.offsetTop = canvasFrame.getBoundingClientRect().top;    //右オフセット

      //トラックボールの回転無効化と回転速度の設定
      trackball.noRotate = false;
      trackball.rotateSpeed = 2.0;

      //トラックボールの拡大無効化と拡大速度の設定
      trackball.noZoom = false;
      trackball.zoomSpeed = 1.0;

      //トラックボールのカメラ中心移動の無効化と中心速度の設定
      trackball.noPan = false;
      trackball.panSpeed = 1.0;
      trackball.target = new THREE.Vector3(0, 0, 10);

      //トラックボールのスタティックムーブの有効化
      trackball.staticMoving = true;
      //トラックボールのダイナミックムーブ時の減衰定数
      trackball.dynamicDampingFactor = 0.3;
    }

    ////////////////////////////////////////////////////////////////////
    // 光源初期化関数の定義
    ////////////////////////////////////////////////////////////////////

    //グローバル変数の宣言
    var directionalLight,  //平行光源オブジェクト
      ambientLight;      //環境光オブジェクト
    function initLight() {
      //平行光源オブジェクトの生成
      directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0, 0);
      //平行光源オブジェクトの位置の設定
      directionalLight.position.set(200, 200, 500);
      //平行光源オブジェクトの影の生成元
      directionalLight.castShadow = true;
      //平行光源オブジェクトのシーンへの追加
      scene.add(directionalLight);

      //平行光源オブジェクトのシャドウマップのサイズ
      directionalLight.shadowMapWidth = 2048;
      directionalLight.shadowMapHeight = 2048;

      //環境光オブジェクトの生成
      ambientLight = new THREE.AmbientLight(0x777777);
      //環境光オブジェクトのシーンへの追加
      scene.add(ambientLight);
    }

    ////////////////////////////////////////////////////////////////////
    // オブジェクト初期化関数の定義
    ////////////////////////////////////////////////////////////////////

    //グローバル変数の宣言
    var sphere; //球オブジェクト
    let racketCube;
    function initObject() {
      //形状オブジェクトの宣言と生成
      var geometry = new THREE.SphereGeometry(ball.radius, 20, 20);
      //材質オブジェクトの宣言と生成
      var material = new THREE.MeshLambertMaterial({ color: 0x99FF00, ambient: 0x880000 });
      //球オブジェクトの生成
      sphere = new THREE.Mesh(geometry, material);
      //球オブジェクトのシーンへの追加
      scene.add(sphere);
      //球オブジェクトの影の生成元
      sphere.castShadow = true;

      //床の描画
      var yuka_n = 20,  //床一辺あたりのタイルの個数
        yuka_w = 10; //タイルの一辺の長さ
      for (var i = -yuka_n / 2; i <= yuka_n / 2; i++) {
        for (var j = -yuka_n / 2; j <= yuka_n / 2; j++) {
          //位置ベクトル
          var x = j * yuka_w;
          var y = i * yuka_w;
          //一辺の長さ「yuka_w」の正方形の形状オブジェクトの宣言と生成
          geometry = new THREE.PlaneGeometry(yuka_w, yuka_w);
          //材質オブジェクトの宣言
          //市松模様とするための材質オブジェクトを生成
          if (Math.abs(i + j) % 2 == 0) {
            material = new THREE.MeshLambertMaterial({ color: 0x999999, ambient: 0x050505 });
          } else {
            material = new THREE.MeshLambertMaterial({ color: 0x4d4d4d, ambient: 0x050505 });
          }
          //平面オブジェクトの宣言と生成
          var plane = new THREE.Mesh(geometry, material);
          //平面オブジェクトの位置の設定
          plane.position.set(x, y, 0);
          //平面オブジェクトに影を描画
          plane.receiveShadow = true;
          //平面オブジェクトのシーンへの追加
          scene.add(plane);
        }
      }
      geometry = new THREE.CubeGeometry(200, 1, roofHeight * 2);
      material = new THREE.MeshLambertMaterial({ color: 0x999999, ambient: 0x050505 });
      plane = new THREE.Mesh(geometry, material);
      plane.position.set(0, sideWallWidth, 10);
      scene.add(plane);

      plane = new THREE.Mesh(geometry, material);
      plane.position.set(0, -sideWallWidth, 10);
      scene.add(plane);

      geometry = new THREE.CubeGeometry(racket.depth, racket.width, racket.height);
      material = new THREE.MeshLambertMaterial({ color: 0xFF0000, ambient: 0x050505 });
      racketCube = new THREE.Mesh(geometry, material);
      racketCube.position.set(racket.x, racket.y, racket.z);
      scene.add(racketCube);
      //球オブジェクトの影の生成元
      racketCube.castShadow = true;
    }

    ////////////////////////////////////////////////////////////////////
    // 無限ループ関数の定義
    ////////////////////////////////////////////////////////////////////
    function KeyIsDown(key_code) {

      if (input_key_buffer[key_code]) return true;

      return false;
    }

    function loop() {
      //トラックボールによるカメラオブジェクトのプロパティの更新
      trackball.update();
      var time = step * dt;
      //時刻の取得
      if (stopFlag == false) {
        for (var k = 0; k < skip; k++) {
          step++;
          time = step * dt;
          //球体の時間発展
          ball.timeEvolution(dt);
        }
        trajectory.push(new THREE.Vector3(ball.x, ball.y, ball.z));
        if (time > 2) {
          trajectory.shift();
        }
      }

      // 上が押されたとき
      if (KeyIsDown(38)) {
        if (racket.z + racket.height / 2 < roofHeight) {
          racket.z += move;
        }
      }

      // 下が押されたとき
      if (KeyIsDown(40)) {
        if (racket.z - racket.height / 2 > 0) {
          racket.z -= move;
        }
      }

      // 左が押されたとき
      if (KeyIsDown(37)) {
        if (racket.y - racket.width / 2 > -sideWallWidth) {
          racket.y -= move;
        }
      }

      // 右が押されたとき
      if (KeyIsDown(39)) {
        if (racket.y + racket.width / 2 < sideWallWidth) {
          racket.y += move;
        }
      }

      //軌跡の描画
      var trajectoryGeometry = new THREE.Geometry();
      trajectoryGeometry.vertices = trajectory;
      var material = new THREE.LineBasicMaterial({ color: 0xff0000 });
      var lines = new THREE.Line(trajectoryGeometry, material);
      scene.add(lines);

      //時刻の取得と出力

      //球オブジェクトの位置ベクトルを設定
      sphere.position.set(ball.x, ball.y, ball.z);
      racketCube.position.set(racket.x, racket.y, racket.z);

      if (restartFlag) {
        restartFlag = false;
        ball = new Ball(initBallParam);
      }

      //クリアーカラーで初期化
      renderer.clear();
      //レンダリング
      renderer.render(scene, camera);
      document.getElementById("score").innerText = score;
      scene.remove(lines);
      //「loop()」関数の呼び出し
      requestAnimationFrame(loop);
    }
  </script>
</head>

<body>
  <!-- タブ切り替えインターフェース領域 -->
  <div id="tabs" style="width: 1300px; height: 730px; margin: 30px;">

    <!-- タブメニューリスト領域 -->
    <ul id="tabList">
      <li><a href="#tab1">仮想３次元空間</a></li>
    </ul>

    <!-- タブコンテンツ領域 -->
    <div id="tab1" class="inner">
      <!-- キャンバスフレーム領域-->
      <div id="canvas-frame" style="width: 1280px;height: 600px; display: block;"></div>

    </div>
    <div style="display: inline-flex; align-content: center; ">
      <input type="button" value="スタート" id="startButton"
        style="display: block; height: 50px; width: 200px; margin: 10px;" />

      <p style="display: inline-block; margin: 10px; font-size: 40px;">十字キーで移動</p>
      <p style="display: inline-block; margin: 10px; font-size: 40px;">　　　Score:</p>
      <p style="display: inline-block; margin: 10px; font-size: 40px;" id="score"></p>
    </div>
  </div>
</body>

</html>